---

layout: post
title: algorithms in a nut shell 1
author: tonie
tags: ['Algorithms']

---

### [{{page.title}}]({{site.baseurl}}{{page.url}}) ###
+ @{{page.date | date_to_string}}

-------------------------------------------------------------------------------

    今天来研究一下《算法技术手册》这本书。
	和《算法导论》以及sedgewick的《算法》不太一样，前两者注重的是内功的修养，提供算法描述的也主要是伪代码为主。毕竟实践中的具体实现不在它们的考量范围中间（越原理性的东西，利用的好，对于我们看待问题就越具有指导意义；如果对于原理云里雾里的，不但容易多走弯路，也不利于发散地去思考问题），从一堆的数学推导以及原理分析的角度去看待算法。而这本书，是从一个实践的角度去看待算法，也就是在具体的软件工程过程中间怎么利用这些算法，并且根据经验作出性能分析以及算法决策。
	三位作者都是研究cs和SE的，他们在这样一本将算法的书中加入了software engineering的元素。SE很注重的就是对于变性以及可变性的分析，对于复杂性的控制和维护，这也将在这本要介绍算法同时又要兼顾到实际使用时的书所需要的。毕竟，越高的抽象层次，面对具体的问题之间天然存在比较大的gap，这个gap或者说算法中的对象与具体问题的mapping是需要对问题的分析来进行填补的。而从另一方面来看，对于某个具体case的过于实际，分析和解决，也会带来一定的问题：在解决问题的过程中，人们难免会将实际问题中的琐碎的细节夹杂到对于具体算法的选择和实施中去。SE重要的思想就是分离这些框架性的和变化的但不是核心的东西，算法本身是核心的抽象。提供对数据类型良好的封装以及行为接口的约定，则在利用算法时，对于数据结构的操作就可以省心得多。例子之后会举。
    以下是几个涉及的原则：	
> 将算法和解决的问题分开；
> 经验支持的数学分析；[这里](http://sourceforge.net/projects/junit)

    不同算法会根据实际的性能分析归类到特定的性能族中去。
	同时也会涉及相似的设计，或者特定的数据结构将对于不同的算法造成如何的影响。
    其中有不同编程语言的实现，也有根据经验提供的性能分析。




	算法的期望运行时间本质上是数学运算的过程。
	对于花费的时间，通常会忽略常数时间因子，O(n)来看待，因为C通常被假设为无足轻重的。






















+ 问题样本的规模；

+ 样本数据的编码方式也有着重要的影响；

+ 紧凑着进行样本编码，可能会降低执行效率；这就需要寻找最优的编码方式；

+ 分析问题时，尽量假设样本编码不影响算法实现，然而不同的编码方式，对于不同的操作将会产生巨大的性能差异；

+ 选择合适的样本编码，从合适的DS开始；

> 样本编码实例：
`检查给定数字X中，1的数目的奇偶性`

> 通常选择大致可以被接受的编码方式；样本为N一般为对象个数，但是实际表示的时候由于字长等因素可能会使得在不同平台上对于相同算法的处理时间发生比较大的变化；

> 如果仅仅是常数倍的差异，那么选择近似忽略，表示为渐进等价，只是作为比较算法时候的通用手段，对细节的重视反映在对于常数的差异的重视上。

与程序性能相关的运行“平台”：
+ 计算机硬件水平
+ 使用的语言及其编译器/解释器
+ 操作系统
+ 其他进程

	一般认为，平台条件的改变，对程序执行的影响，是在原有时间上调整一个常数因子；

e.g. Page 23 对于元素周期表的编码：
多利用primitive ds的一些优势，比如数组或者链表；
不同编码对于程序执行性能的影响特别大；

C×n；在n越来越大时，c变得不再重要
通过n达到一定程度进行选择性忽略因素的时候，我们也要注意到：
当实际中n的需求量一般不是那么大时；
C的实际取值，对于实际问题的意义；

增长率在于需求不断扩张时，而如果需求被限定在固定或者较小的范围中时，增长率不是主要因素；

对于许多问题而言，并不存在单一最优的算法，需要知道这个问题的处理数据规模的概率分布情况，以及实际的性能测试情况；不同分布的数据可能对于不同的算法的优劣评估结果产生很明显的影响。


分为三方面的分析：
	最坏情况：最坏的运行性能
		实际运行的限制需要；最长运行时间
		Sn是set的子集，t表示算法运行时间，那么t(Sn)是t(si)max[s1 belongs to set]
		Tn定义了Sn作为最坏情况下的复杂度。

	平均情况：期望视角;
		是每种情况出现的概率及其运行时间的一个期望值；expectation
	
	最好情况：少见；最优情况；如果相对于最坏情况最好情况没有明显的改善，那么不要轻易使用；












分类：
+ c
对于primitive类型基本默认为常数时间；对于操作耗时，并不考虑硬件耗时；

+ logn
折半查找，效率高，迅速完成收敛；每次完成查找迭代目标个数都减半；
折半思想也体现在newton's method中间；

+ n^(1/m)
KD-tree
高效划分n个多维点？？？

+ n
考虑线性叠加？
result := a[i] + b[i] + carry[i]
c[i] := result mod 10
carry[i+1] := 1 if result > 0
		      0 else

编程语言是如何影响性能的
计算机硬件是如何影响性能的

整数最长位数固定时，加法的常数时间是可达的

操作非2的倍数时，mod是出了名的慢
说明在一些细节上，对于常数c也不能掉以轻心。
	
+ nlogn
分治法：
	分解成两个子问题，并且进行分别处理，最终将处理结果进行统一的归并；
	t(n) = 2 * t(n/2) + O(n)
	t(n) = 2^k * t(n/2^k) + O(k * n)
	n = 2^k时停止扩展；
	此时为 n + O(nlogn)

+ n^2 or multi
	两个数字进行相乘时；
	算法本身的直接二次方性能不可能被超越；
	在进行计算时应当尽可能避开mod运算

	而对于性能不明显的计算：
	迭代次数不明显，取决于输入数据的特征；

优化一个操作将可能降低另一个操作的性能；


+ 2^n
基准测试；
对于基础测试的假设中，计算与依赖的平台是相互独立的
依赖的结构非常抽象，对于我们来说是好是坏呢？
扯到lisp了...









































